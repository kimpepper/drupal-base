<?php
// $Id: nodequeue.module,v 1.71 2009/02/01 17:17:14 ezrag Exp $

// --------------------------------------------------------------------------
// Drupal Hooks

/**
 * Implementation of hook_perm
 */
function nodequeue_perm() {
  return array('manipulate queues', 'administer nodequeue', 'manipulate all queues');
}

/**
 * Implementation of hook_init().
 *
 * Loads subsidiary includes for other modules.
 */
function nodequeue_init() {
  include_once drupal_get_path('module', 'nodequeue') .'/includes/nodequeue.actions.inc';
}

/**
 * Helper function - since hook_menu now takes a function instead of a boolean, this function is used to compute the user's access.
 *
 * @return boolean
 */
function _nodequeue_access_admin_or_manipulate() {
  return user_access('administer nodequeue') || user_access('manipulate queues');
}

/**
 * Implementation of hook_menu
 */
function nodequeue_menu() {
  $items = array();

  $admin_access = array('administer nodequeue');
  $access = array('manipulate queues');

  // administrative items
  $items['admin/content/nodequeue'] = array(
    'title' => 'Nodequeue',
    'access callback' => '_nodequeue_access_admin_or_manipulate',
    'page callback' => 'nodequeue_view_queues',
    'description' => 'Create and maintain simple nodequeues.',
    'type' => MENU_NORMAL_ITEM
  );
  $items['admin/content/nodequeue/list'] = array(
    'title' => 'List',
    'access callback' => '_nodequeue_access_admin_or_manipulate',
    'page callback' => 'nodequeue_view_queues',
    'weight' => -1,
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  $items['admin/content/nodequeue/settings'] = array(
    'title' => 'Settings',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_admin_settings'),
    'type' => MENU_LOCAL_TASK
  );
  $items['nodequeue/autocomplete'] = array(
    'title' => 'Autocomplete',
    'access arguments' => $access,
    'page callback' => 'nodequeue_autocomplete',
    'type' => MENU_CALLBACK
  );
  $items['nodequeue/ajax/add'] = array(
    'title' => 'ajax add',
    'access arguments' => $access,
    'page callback' => 'nodequeue_ajax_add',
    'type' => MENU_CALLBACK
  );
  $info = nodequeue_api_info();
  foreach ($info as $key => $data) {
    $items['admin/content/nodequeue/add/'. $key] = array(
      'title' => 'Add @type',
      'title arguments' => array('@type' => strtolower($data['title'])),
      'access arguments' => $admin_access,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('nodequeue_edit_queue_form', $key),
      'type' => MENU_LOCAL_TASK
    );
  }

  // Note: This path used to set up with a call to nodequeue_load_queues_by_type, passing the result in.  Now, that function is called inside of nodequeue_node_tab.

  $items['node/%node/nodequeue'] = array(
    'title' => '@tab',
    'title arguments' => array('@tab' => variable_get('nodequeue_tab_name', 'Nodequeue')),
    'access callback' => 'nodequeue_node_tab_access',
    'access arguments' => array(1),
    'page callback' => 'nodequeue_node_tab',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5
  );

  // Administrative items for an individual queue.
  $items['admin/content/nodequeue/%nodequeue'] = array(
    'access arguments' => array(3),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_view',
    'page arguments' => array(3),
    'type' => MENU_CALLBACK
  );
  $items['admin/content/nodequeue/%nodequeue/view/%subqueue'] = array(
    'title' => 'View',
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_view',
    'page arguments' => array(3, 5),
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK
  );
  // Actual administrative items.
  $items['admin/content/nodequeue/%nodequeue/edit'] = array(
    'title' => 'Edit',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_edit_queue_form', 3),
    'type' => MENU_LOCAL_TASK
  );
  $items['admin/content/nodequeue/%nodequeue/delete'] = array(
    'title' => 'Delete',
    'access arguments' => $admin_access,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_admin_delete', 3),
    'weight' => 5,
    'type' => MENU_CALLBACK
  );

      /*$sqid = arg(5);
      if (is_numeric($sqid) && $subqueue = nodequeue_load_subqueue($sqid)) {
        // The following operations require a sqid and a nid.
        $nid = arg(6);
        if (in_array(arg(4), array('add', 'remove-node')) &&
            is_numeric($nid)) {
          $node = node_load($nid);
        }*/

  $items["admin/content/nodequeue/%nodequeue/add/%subqueue/%node"] = array(
    'access arguments' => array(6, 3, 5),
    'access callback' => 'nodequeue_node_and_queue_access',
    'page callback' => 'nodequeue_admin_add_node',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/remove-node/%subqueue/%node"] = array(
    'access arguments' => array(6, 3, 5),
    'access callback' => 'nodequeue_node_and_queue_access',
    'page callback' => 'nodequeue_admin_remove_node',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/up/%subqueue/%"] = array(
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_up',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/down/%subqueue/%"] = array(
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_down',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/front/%subqueue/%"] = array(
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_front',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/back/%subqueue/%"] = array(
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_back',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/remove/%subqueue/%"] = array(
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'nodequeue_admin_remove',
    'page arguments' => array(3, 5, 6),
    'type' => MENU_CALLBACK
  );
  $items["admin/content/nodequeue/%nodequeue/clear/%subqueue"] = array(
    'title' => 'Clear',
    'access arguments' => array(3, 5),
    'access callback' => 'nodequeue_queue_access',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodequeue_clear_confirm', 3, 5),
    'type' => MENU_CALLBACK
  );

  return $items;
}
/**
 * Implementation of hook_nodeapi
 */
function nodequeue_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'delete':
      // If a node is being deleted, ensure it's also removed from any queues.
      $result = db_query("SELECT qid, sqid FROM {nodequeue_nodes} WHERE nid = %d", $node->nid);
      while ($obj = db_fetch_object($result)) {
        // If the queue is being tracked by translation set and the node is part
        // of a translation set, don't delete the queue record.
        // Instead, data will be updated in the 'translation_change' op, below.
        $queues = nodequeue_load_queues(array($obj->qid));
        $queue = nodequeue_load_queues($obj->qid);
        if (!$queue->i18n || empty($node->tnid)) {
          // This removes by nid, not position, because if we happen to have a
          // node in a queue twice, the 2nd position would be wrong.
          nodequeue_subqueue_remove_node($obj->sqid, $node->nid);
        }
      }
      break;
    case 'translation_change':
      if (isset($node->translation_change)) {
        // If there is only one node remaining, track by nid rather than tnid.
        // Otherwise, use the new tnid.
        $content_id = $node->translation_change['new_tnid'] == 0 ? $node->translation_change['remaining_nid'] : $node->translation_change['new_tnid'];
        db_query("UPDATE {nodequeue_nodes} SET nid = %d WHERE nid = %d", $content_id, $node->translation_change['old_tnid']);
      }
  }
}

/**
 * Implementation of hook_link
 */
function nodequeue_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();

  if ($type == 'node' &&
      variable_get('nodequeue_links', FALSE) &&
      user_access('manipulate queues')) {
    $queues = nodequeue_load_queues_by_type($node->type, 'links');
    $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
    if (empty($subqueues)) {
      return;
    }

    // resort the subqueues to retain consistent ordering:

    ksort($subqueues);
    // Due to caching, we can accidentally get positions leftover
    // from previous iterations on teaser list pages, so we must
    // remove any existing positions here.
    foreach ($subqueues as $id => $subqueue) {
      unset($subqueues[$id]->position);
    }

    if(!module_exists('translation')) {
      nodequeue_set_subqueue_positions($subqueues, $node->nid);
    }

    foreach ($subqueues as $subqueue) {
      $queue = $queues[$subqueue->qid];
      $id = nodequeue_get_content_id($queue, $node);
      if(module_exists('translation')) {
        $subqueue = array($subqueue->sqid => $subqueue);
        nodequeue_set_subqueue_positions($subqueue, $id);
        $subqueue = array_shift($subqueue);
      }
      $query_string = nodequeue_get_query_string($id, TRUE);
      $class = 'nodequeue-ajax-toggle nodequeue-toggle-q-'. $queue->qid. ' nodequeue-toggle-sq-'. $subqueue->sqid .' nodequeue-toggle-ref-'. $subqueue->reference;
      if (!isset($subqueue->position)) {
        $links[$class] = array(
          'title' => nodequeue_title_substitute($queue->link, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$id",
          'attributes' => array('class' => $class . ' toggle-add'),
          'query' => $query_string);
      }
      else if ($queue->link_remove) {
        $links[$class] = array(
          'title' => nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
          'href' => "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$id",
          'attributes' => array('class' => $class .' toggle-remove'),
          'query' => $query_string);
      }
    }
    drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
    drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');
  }
  return $links;
}

/**
 * Implementation of hook_views_api()
 */

function nodequeue_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'nodequeue') .'/includes/views',
  );
}
// --------------------------------------------------------------------------
// Nodequeue Admin operations

/**
 * Print the JSON output for our AJAX calls.
 */
function nodequeue_js_output($label, $href, $count = NULL, $sqid = NULL) {
  $return = new stdClass();
  $return->status = 1;
  $return->label = check_plain($label);
  $return->href = $href;
  if (isset($count)) {
    $return->count = $count;
  }
  if (isset($sqid)) {
    $return->sqid = $sqid;
  }

  drupal_json($return);
  exit;
}

/**
 * Return content id based on i18n settings
 */
function nodequeue_get_content_id($queue, $node) {
  return ($queue->i18n && !empty($node->tnid)) ? $node->tnid : $node->nid;
}

/**
 * Page callback to add a node to a queue.
 */
function nodequeue_admin_add_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }
  $id = nodequeue_get_content_id($queue, $node);
  nodequeue_subqueue_add($queue, $subqueue, $id);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Remove from queue'),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE, array('tab')))),
        nodequeue_subqueue_size_text($queue->size, $queue->size ? min($subqueue->count + 1, $queue->size) : $subqueue->count + 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link_remove, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE))));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Page callback to remove a node from a queue.
 */
function nodequeue_admin_remove_node($queue, $subqueue, $node) {
  if (!nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }
  $id = nodequeue_get_content_id($queue, $node);
  nodequeue_subqueue_remove_node($subqueue->sqid, $id);

  // Provide a response if this is javascript.
  if (!empty($_POST['js'])) {
    if (isset($_GET['tab'])) {
      nodequeue_js_output(t('Add to queue'),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE, array('tab')))),
        nodequeue_subqueue_size_text($queue->size, $subqueue->count - 1, FALSE),
        $subqueue->sqid);
    }
    else {
      nodequeue_js_output(nodequeue_title_substitute($queue->link, $queue, $subqueue),
        url("admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid", array('query' => nodequeue_get_query_string($node->nid, TRUE))));
    }
  }

  // There should always be a destination set for this, so just goto wherever.
  drupal_goto();
}

/**
 * Display the queue controls for a node.
 *
 * @param $node
 *   The loaded $node; will be loaded by the hook_menu.
 */
function nodequeue_node_tab($node) {
  $output = '';

  // moved from hook_menu due to architecture change.  This function seems to only be called from menu anyway...
  $queues = nodequeue_load_queues_by_type($node->type, 'tab');
  if (!$queues) {
    return FALSE;
  }
  $header = array();
  $header[] = array('data' => t('Title'), 'class' => 'nodequeue-title');
  if (variable_get('nodequeue_tab_display_max', 1)) {
    $header[] = array('data' => t('Max nodes'), 'class' => 'nodequeue-max-nodes');
  }
  $header[] = array('data' => t('In queue'), 'class' => 'nodequeue-in-queue');
  $header[] = array('data' => t('Operation'), 'class' => 'nodequeue-operation');
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);

  nodequeue_set_subqueue_positions($subqueues, $node->nid);

  $rows = array();
  foreach ($subqueues as $subqueue) {
    $queue = $queues[$subqueue->qid];
    if (empty($subqueue->position)) {
      $op = l(
        t('Add to queue'),
        "admin/content/nodequeue/$queue->qid/add/$subqueue->sqid/$node->nid",
        array('attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid))
      );
    }
    else {
      $op = l(
        t('Remove from queue'),
        "admin/content/nodequeue/$queue->qid/remove-node/$subqueue->sqid/$node->nid",
        array('attributes' => array('class' => 'nodequeue-ajax-toggle'),
          'query' => drupal_get_destination() .'&tab&'. nodequeue_get_token($node->nid))
      );
    }
    $row = array();
    $row[] = array(
      'class' => 'nodequeue-title',
      'data' => l(nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"),
    );
    if (variable_get('nodequeue_tab_display_max', 1)) {
      $row[] = array('class' => 'nodequeue-max-nodes', 'data' => $queue->size ? $queue->size : t('Infinite'));
    }
    $row[] = array(
      'id' => 'nodequeue-count-'. $subqueue->sqid,
      'class' => 'nodequeue-in-queue',
      'data' => nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE)
    );
    $row[] = array('class' => 'nodequeue-operation', 'data' => $op);
    $rows[] = $row;
  }

  $output .= theme('table', $header, $rows, array('class' => 'nodequeue-table'));
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');
  return $output;
}

/**
 * Display a list of queues and their status for the administrator.
 */
function nodequeue_view_queues() {
  $output = theme('advanced_help_topic', 'nodequeue', 'about', 'icon') . '&nbsp;' . theme('advanced_help_topic', 'nodequeue', 'about', t('Click here for information about this module'));
  // Fetch all of the queues.
  $queues = nodequeue_load_queues(nodequeue_get_all_qids(25));
  foreach ($queues as $queue) {
    if (!nodequeue_queue_access($queue)) {
      unset($queues[$queue->qid]);
    }
  }

  if (empty($queues)) {
    return $output . t('No nodequeues exist.');
  }

  $header = array(
    array('data' => t('Title'), 'field' => 'title', 'sort' => 'asc'),
    array('data' => t('Max nodes'), 'field' => 'size'),
    array('data' => t('Subqueues'), 'field' => 'subqueues'),
    array('data' => t('Operation')),
  );
  $table_sort = tablesort_init($header);

  $qids = array();
  $sort_primary = array();
  $sort_secondary = array();
  $sort_direction_regular = array('asc' => SORT_ASC, 'desc' => SORT_DESC);
  $sort_direction_reverse = array('asc' => SORT_DESC, 'desc' => SORT_ASC);
  foreach ($queues as $queue) {
    // If a queue has only one subqueue, store the qid so we can display
    // the number of nodes in the subqueue.
    if ($queue->subqueues == 1) {
      $qids[] = $queue->qid;
    }
    $sort_secondary[] = $queue->title;
    switch ($table_sort['sql']) {
      case 'title':
      default:
        $sort_primary[] = $queue->title;
        $sort_direction = $sort_direction_regular;
        break;
      case 'size':
        $sort_primary[] = $queue->size;
        $sort_direction = $sort_direction_reverse;
        break;
      case 'subqueues':
        $sort_primary[] = $queue->subqueues;
        $sort_direction = $sort_direction_regular;
        break;
    }
  }

  $subqueues = nodequeue_load_subqueues_by_queue($qids);
  // Relate all the subqueues we loaded back to our queues.
  foreach ($subqueues as $subqueue) {
     if (nodequeue_api_subqueue_access($subqueue, NULL, $queues[$subqueue->qid])) {
       $queues[$subqueue->qid]->subqueue = $subqueue;
     }
  }

  if (!empty($table_sort)) {
    if (strtolower($table_sort['sort']) == 'desc') {
      array_multisort($sort_primary, $sort_direction['desc'], $sort_secondary, $queues); // Re-indexes array keys; key no longer equals qid.
    }
    else {
      array_multisort($sort_primary, $sort_direction['asc'], $sort_secondary, $queues); // Re-indexes array keys; key no longer equals qid.
    }
  }

  $rows = array();
  foreach ($queues as $queue) {
    $sub_text = $queue->subqueues;
    if ($sub_text == 1) {
      $sub_text .= " (". nodequeue_subqueue_size_text($queue->size, $queue->subqueue->count) .")";
    }

    $operations = array(l(t('View'), "admin/content/nodequeue/$queue->qid/view"));
    if (user_access('administer nodequeue')) {
      $operations[] = l(t('Edit'), "admin/content/nodequeue/$queue->qid/edit");
      $operations[] = l(t('Delete'), "admin/content/nodequeue/$queue->qid/delete");
    }

    $rows[] = array(
      array('class' => 'nodequeue-title', 'data' => check_plain($queue->title)),
      array('class' => 'nodequeue-max-nodes', 'data' => $queue->size == 0 ? t('Infinite') : $queue->size),
      array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
      array('class' => 'nodequeue-operation', 'data' => implode(' | ', $operations)),
    );
  }

  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 25);

  return  $output;
}

/**
 * Display a list of subqueues for a queue and their sizes
 */
function nodequeue_view_subqueues($queue) {
  // Fetch all of the subqueues.
  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);

  $header = array(t('Title'), t('In queue'), t('Operation'));

  $rows = array();
  foreach ($subqueues as $subqueue) {
    if (nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      $sub_text = nodequeue_subqueue_size_text($queue->size, $subqueue->count, FALSE);
      $rows[] = array(
        array('class' => 'nodequeue-title', 'data' => check_plain($subqueue->title)),
        array('class' => 'nodequeue-subqueues', 'data' => $sub_text),
        array('class' => 'nodequeue-operation', 'data' => l(t('View'), "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid"))
      );
    }
  }

  $output = '<p>'. t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) .'</p>';
  $output .= theme('table', $header, $rows);
  $output .= theme('pager', NULL, 20);

  return  $output;
}

/**
 * Add or edit a queue.
 */
function nodequeue_edit_queue_form(&$form_state, $queue) {
  $info = nodequeue_api_info();

  // For adding queues.
  if (is_string($queue)) {
    // If the $queue is a string - name of a queue type, basically - then we test that it's a valid queue type.
    $queue = strtolower($queue);
    if (!isset($info[$queue])) {
      return false;
    }
    drupal_set_title(t('Add @type', array('@type' => strtolower($info[$queue]['title']))));
    $queue = new nodequeue_queue($queue);
  }
  else {
    drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  }

  $form['description'] = array(
    '#type' => 'fieldset',
    '#title' => $info[$queue->owner]['title'],
    '#description' => $info[$queue->owner]['description'],
  );

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#default_value' => $queue->title,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('Enter the name of the queue'),
  );

  // This is a value; as the default nodequeue implementation has just one
  // queue per nodequeue, this field is totally redundant. Plugins can
  // override this.
  $form['subqueue_title'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueue_title,
  );
  // The placeholder is put here so that modifiers have an easy way to put
  // additional form widgets in a prominent spot but not before the title of
  // the queue.
  $form['placeholder'] = array();

  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Queue size'),
    '#default_value' => $queue->size,
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('The maximum number of nodes will appear in the queue. Enter 0 for no limit'),
  );

  $form['reverse'] = array(
    '#type' => 'checkbox',
    '#title' => t('Reverse in admin view'),
    '#default_value' => $queue->reverse,
    '#description' => t('Ordinarily queues are arranged with the front of the queue (where items will be removed) on top and the back (where items will be added) on the bottom. If checked, this will display the queue such that items will be added to the top and removed from the bottom.'),
  );

  $form['link'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "add to queue" text'),
    '#default_value' => $queue->link,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('If you want a link to add a node to a queue in the "links" section (next to "add new comment"), enter the text here. If left blank no link will be given; note that enabling this feature for any queue will cause an extra query to be run every time a node is loaded. "%subqueue" will be replaced with the subqueue title, if applicable.'),
  );

  $form['link_remove'] = array(
    '#type' => 'textfield',
    '#title' => t('Link "remove from queue" text'),
    '#default_value' => $queue->link_remove,
    '#size' => 40,
    '#maxlength' => 40,
    '#description' => t('Enter the text for the corresponding link to remove a node from a queue. This may be blank (in which case no link will appear) but a remove link will only appear if link, above, is set.'),
  );


  $result = db_query("SELECT r.* FROM {role} r LEFT JOIN {permission} p ON p.rid = r.rid WHERE p.perm LIKE '%manipulate queues%' ORDER BY r.name");

  $roles = array();
  while ($role = db_fetch_object($result)) {
    $roles[$role->rid] = $role->name;
  }

  if (!empty($roles)) {
    $form['roles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Roles'),
      '#default_value' => is_array($queue->roles) ? $queue->roles : array(),
      '#options' => $roles,
      '#description' => t('Check each role that can add nodes to the queue. Be sure that roles you want to appear here have "manipulate queues" access in the main access control panel.'),
    );
  }
  else {
    $form['roles'] = array(
      '#type' => 'value',
      '#value' => array(),
    );

    $form['roles_markup'] = array(
      '#value' => t('No roles have the "manipulate queues" permission, so only the administrator account will be able to add or remove items from this queue.'),
    );
  }

  $nodes = node_get_types('names');

  $form['types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Types'),
    '#default_value' => $queue->types,
    '#options' => $nodes,
    '#description' => t('Check each node type that can be added to this queue.'),
  );

  $form['i18n'] = array(
    '#type' => 'radios',
    '#title' => t('Internationalization'),
    '#options' => array(
      '1' => t('Treat translation nodes as a single node'),
      '0' => t('Manually manage translated nodes'),
    ),
    '#default_value' => empty($queue->qid) && module_exists('translation_helpers') ? 0 : $queue->i18n,
    '#description' => t('Treating translations as a single node allows users to add, remove and manipulate a node
      in the queue regardless of which translation is acted upon; nodequeue will only act on the original node.
      When manually managing translation nodes, Nodequeue will ignore the relationship between node translations; 
      each translation node must be added to the queue separately and will occupy a separate spot in the queue. 
      Changing this setting will <strong>not</strong> update content that is already in the queue.'),
    '#access' => module_exists('translation_helpers'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['owner'] = array(
    '#type' => 'value',
    '#value' => $queue->owner,
  );

  $form['show_in_links'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_links,
  );

  $form['show_in_tab'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_tab,
  );

  $form['show_in_ui'] = array(
    '#type' => 'value',
    '#value' => $queue->show_in_ui,
  );

  $form['reference'] = array(
    '#type' => 'value',
    '#value' => $queue->reference,
  );

  $form['subqueues'] = array(
    '#type' => 'value',
    '#value' => $queue->subqueues,
  );

  if (isset($queue->qid)) {
    $form[] = array(
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#validate' => array('nodequeue_edit_queue_form_delete_validate'),
      '#submit' => array('nodequeue_edit_queue_form_delete_submit'),
    );
    $form['qid'] = array(
      '#type' => 'value',
      '#value' => $queue->qid,
    );
    $form['count'] = array(
      '#type' => 'value',
      '#value' => $queue->count,
    );
  }

  nodequeue_api_queue_form($queue, $form);

  return $form;
}

/**
 * Validate function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_validate($form, &$form_state) {
  if (empty($form_state['values']['title'])) {
    form_set_error('title', t('Please enter a title for this queue.'));
  }
  $queue = (object) $form_state['values'];
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  nodequeue_api_queue_form_validate($queue, $form_state, $form);
}

/**
 * Submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_submit($formid, &$form_state) {
  $queue = (object) $form_state['values'];
  // fix checkboxes
  $queue->roles = array_keys(array_filter($queue->roles));
  $queue->types = array_keys(array_filter($queue->types));

  if (!isset($queue->qid)) {
    $queue->new = TRUE;
  }

  // Modify show_in_links based on whether or not links are available.
  $queue->show_in_links = !empty($queue->link) && !empty($queue->link_remove);

  nodequeue_api_queue_form_submit($queue, $form_state);

  $qid = nodequeue_save($queue); // sets $queue->qid if needed.

  nodequeue_api_queue_form_submit_finish($queue, $form_state);

  nodequeue_check_subqueue_sizes($queue);

  if ($queue->new) {
    drupal_set_message(t('The queue has been created.'));
  }
  else {
    drupal_set_message(t('The queue has been updated.'));
  }
  $form_state['redirect'] = 'admin/content/nodequeue';
}

/**
 * Delete-validate function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_delete_validate($form, &$form_state) {
  // No validation for delete step!  But we need to have this so the default validation isn't called.
}

/**
 * Delete-submit function for the nodequeue_queue form.
 */
function nodequeue_edit_queue_form_delete_submit($formid, &$form_state) {
  $form_state['redirect'] = "admin/content/nodequeue/". $form_state['values']['qid'] ."/delete";
}

/**
 * Confirm form to delete a queue
 */
function nodequeue_admin_delete(&$form_state, $queue) {
  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Are you sure you want to delete "%title"?', array('%title' => $queue->title)),
    $_GET['destination'] ? $_GET['destination'] : 'admin/content/nodequeue',
    t('This action cannot be undone.'),
    t('Delete'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue delete
 */
function nodequeue_admin_delete_submit($formid, &$form_state) {
  if ($form_state['values']['confirm']) {
    nodequeue_delete($form_state['values']['qid']);
    drupal_set_message(t('The queue has been deleted.'));
  }
  $form_state['redirect'] = 'admin/content/nodequeue';
}

/**
 * Page callback to view a queue.
 */
function nodequeue_admin_view($queue, $subqueue = NULL) {
  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  $qid = $queue->qid;

  // If the queue has just one subqueue, it gets special treatment.
  if (!$subqueue->sqid) {
    if ($queue->subqueues == 1) {
      $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
      $subqueue = array_shift($subqueues);
    }
    else {
      // display subqueue list page.
      return nodequeue_view_subqueues($queue);
    }
  }
  else if ($subqueue->sqid) {
   if (!nodequeue_api_subqueue_access($subqueue, NULL, $queue)) {
      return drupal_not_found();
    }
    // Adjust properties of the page so our subqueue is in the right
    // visual place.
    drupal_set_title(t("Subqueue '@title'",
      array('@title' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))));
    $breadcrumb = drupal_get_breadcrumb();
    $breadcrumb[] = l($queue->title, "admin/content/nodequeue/$queue->qid");
    drupal_set_breadcrumb($breadcrumb);
  }
  return nodequeue_arrange_subqueue($queue, $subqueue);
}

function nodequeue_arrange_subqueue_entry($queue, $subqueue, $node) {
  $qid = $queue->qid;
  $sqid = $subqueue->sqid;
  $query_string = nodequeue_get_query_string($node->position, TRUE);

  $buttons = l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-up.png', t('Move up')),
    "admin/content/nodequeue/$qid/up/$sqid/$node->position",
    array('attributes' => array(
      'title' => t('Move up'),
      'class' => 'nodequeue-move-up',
    ), 'query' => $query_string, 'html' => TRUE));
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-down.png', t('Move down')),
    "admin/content/nodequeue/$qid/down/$sqid/$node->position",
    array('attributes' => array(
      'title' => t('Move down'),
      'class' => 'nodequeue-move-down',
    ), 'query' => $query_string, 'html' => TRUE));
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-top.png', t('Move to front')),
    "admin/content/nodequeue/$qid/front/$sqid/$node->position",
    array('attributes' => array(
      'title' => t('Move to front'),
      'class' => 'nodequeue-move-front',
    ), 'query' => $query_string, 'html' => TRUE));
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/go-bottom.png', t('Move to back')),
    "admin/content/nodequeue/$qid/back/$sqid/$node->position",
    array('attributes' => array(
      'title' => t('Move to back'),
      'class' => 'nodequeue-move-back',
    ), 'query' => $query_string, 'html' => TRUE));
  $buttons .= l(
    theme('image', drupal_get_path('module', 'nodequeue') .'/images/delete.png', t('Remove from queue')),
    "admin/content/nodequeue/$qid/remove/$sqid/$node->position",
    array('attributes' => array(
      'title' => t('Remove from queue'),
      'class' => 'nodequeue-remove',
    ), 'query' => $query_string, 'html' => TRUE));

  $output = '<tr id="nodequeue-row-'. $node->position .'" class="nodequeue-row '. ($node->position % 2 ? 'odd' : 'even') .'">';
  $output .= '<td>'. l($node->title, "node/$node->nid") .'</td>';
  $output .= '<td>'. theme('username', $node) .'</td>';
  $output .= '<td>'. format_date($node->created) .'</td>';
  $output .= '<td>'. $buttons .'</td>';
  $output .= '</tr>';
  return $output;
}

/**
 * View the contents of a subqueue, with links to re-order the queue.
 */
function nodequeue_arrange_subqueue($queue, $subqueue) {
  $qid = $queue->qid;
  $sqid = $subqueue->sqid;
  $output = '';

  $order = $queue->reverse ? 'DESC' : 'ASC';
  $result = db_query("SELECT DISTINCT(n.nid), n.title, n.uid, u.name, n.created, nq.position FROM {node} n LEFT JOIN {users} u on n.uid = u.uid LEFT JOIN {nodequeue_nodes} nq ON nq.nid = n.nid WHERE nq.sqid = %d ORDER BY nq.position $order", $sqid);

  $body = '';

  $nids = array();
  while ($node = db_fetch_object($result)) {
    $nids[$node->position] = $node->nid;
    $body .= nodequeue_arrange_subqueue_entry($queue, $subqueue, $node);
  }

  $output = '<p>'. t('Max nodes in queue: @size', array('@size' => $queue->size ? $queue->size : t("Infinite"))) .'</p>';

  $output .= '<p class="nodequeue-hide-if-not-js nodequeue-warning">';
  $output .= t('Changes made to the queue order and queue removals will not be active until you click Save, below. If you add more nodes than the queue can hold, they will be removed from the @end when you save!', array('@end' => $queue->reverse ? t('bottom') : t('top')));
  $output .= '</p>';

  $output .= '<table id="nodequeue-table">';
  $output .= '<thead>';
  $output .= '<tr>';
  $output .= '<th class="nodequeue-node">'. t('Node') .'</th>';
  $output .= '<th class="nodequeue-author">'. t('Author') .'</th>';
  $output .= '<th class="nodequeue-date">'. t('Date') .'</th>';
  $output .= '<th class="nodequeue-operation">'. t('Operation') .'</th>';
  $output .= '</thead>';
  $output .= '<tbody>'. $body .'</tbody>';
  $output .= '</table>';

  $output .= drupal_get_form('nodequeue_arrange_subqueue_form', $queue, $sqid, $nids);
  drupal_add_js(drupal_get_path('module', 'nodequeue') .'/nodequeue.js');

  return $output;
}

/**
 * Form used for arranging a queue
 */
//TODO: Form - Revise for D6
function nodequeue_arrange_subqueue_form($form_state, $queue, $sqid, $nids) {
  $form['qid'] = array(
    '#type' => 'value',
    '#value' => $queue->qid,
  );

  $form['sqid'] = array(
    '#type' => 'hidden',
    '#value' => $sqid,
  );

  $form['order'] = array(
    '#type' => 'hidden',
    '#id' => 'nodequeue-order',
    '#default_value' => implode(',', array_keys($nids)),
  );

  $form['add'] = array(
    '#type' => 'textfield',
    '#title' => t('Select title to add'),
    '#autocomplete_path' => "nodequeue/autocomplete/$sqid",
    '#default_value' => '',
  );

  // For use by the validate handler
  $form['nid'] = array(
    '#type' => 'value',
    '#value' => 0,
  );

  $form['add_submit'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-add'),
    '#value' => t('Add'),
    '#validate' => array('nodequeue_arrange_subqueue_form_add_validate'),
    '#submit' => array('nodequeue_arrange_subqueue_form_add_submit'),
  );

  $form['save'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-hide-if-not-js-hide nodequeue-save'),
    '#value' => t('Save'),
    '#validate' => array('nodequeue_arrange_subqueue_form_save_validate'),
  );

  $form['clear'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-clear'),
    '#value' => t('Clear'),
    '#submit' => array('nodequeue_arrange_subqueue_form_clear_submit'),
  );

  $form['reverse_click'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-reverse'),
    '#value' => t('Reverse'),
    '#submit' => array('nodequeue_arrange_subqueue_form_submit'),
  );

  $form['shuffle'] = array(
    '#type' => 'submit',
    '#attributes' => array('class' => 'nodequeue-shuffle'),
    '#value' => t('Shuffle'),
    '#submit' => array('nodequeue_arrange_subqueue_form_shuffle_submit'),
  );

  // Store the original order.
  $form['nids'] = array(
    '#type' => 'value',
    '#value' => $nids,
  );

  $form['added_nids'] = array(
    '#type' => 'hidden',
    '#default_value' => '',
  );

  $settings = array(
    'nodequeue-table' => array(
      // The gadget that stores our the order of items.
      'order' => 'input#nodequeue-order',
      // The buttons that do stuff.
      'up' => 'a.nodequeue-move-up',
      'down' => 'a.nodequeue-move-down',
      'top' => 'a.nodequeue-move-front',
      'bottom' => 'a.nodequeue-move-back',
      'remove' => 'a.nodequeue-remove',

      // The button that adds an item
      'add' => 'input.nodequeue-add',
      // The buttom to clear the queue
      'clear_list' => 'input.nodequeue-clear',
      // Path for js to shuffle the queue
      'shuffle' => 'input.nodequeue-shuffle',
      // Path for js to reverse the queue
      'reverse' => 'input.nodequeue-reverse',
      // Path for ajax on adding an item
      'path' => url('nodequeue/ajax/add', array('absolute' => TRUE)),
      // Which items to post when adding
      'post' => array('#edit-sqid', '#edit-add'),
      // Where to get the id of an item
      'tr' => 'nodequeue-row-',
      'row_class' => 'tr.nodequeue-row',
      // Where to put the extra (we're storing a nid)
      'extra' => '#edit-added-nids',
      // What item to focus on ready
      'focus' => '#edit-add',
      // What item(s) to clear after add
      'clear' => array('#edit-add'),
      // What hidden class to show as soon as anything has changed that needs saving.
      'hidden' => '.nodequeue-js-hide',
      // Do we add to the top or the bottom?
      'add_location' => $queue->reverse ? 'top' : 'bottom',
    ),
  );
  drupal_add_js(array('nodequeue' => $settings), 'setting');
  drupal_add_css(drupal_get_path('module', 'nodequeue') .'/nodequeue.css');

  return $form;
}

/**
 * Implements hook_theme.
 *
 * @return unknown
 */
function nodequeue_theme() {
  return array(
    'nodequeue_arrange_subqueue_form' => array(
      'arguments' => array('form'),
    ),
    'nodequeue_subqueue_empty_text' => array(
      'arguments' => array(),
    ),
    'nodequeue_subqueue_full_text' => array(
      'arguments' => array(),
    ),
    'nodequeue_subqueue_count_text' => array(
      'arguments' => array(),
    ),
  );
}

//TODO: Theme function for Form - do we need to revise?
function theme_nodequeue_arrange_subqueue_form($form) {
  $header = array(
    check_plain($form['add']['#title']),
    '',
  );

  unset($form['add']['#title']);
  $rows = array(
    drupal_render($form['add']),
    array('data' => drupal_render($form['add_submit']), 'width' => '80%'),
  );

  $output = theme('table', $header, array($rows));
  $output .= drupal_render($form);
  return $output;
}

/**
 * Validate handler for nodequeue_arrange_subqueue_form
 */
function nodequeue_arrange_subqueue_form_validate($form, &$form_state) {
  // Default Validator - does nothing
}

/**
 * Validate handler for nodequeue_arrange_subqueue_form for 'Add' button.
 *
 * @param unknown_type $form_id
 * @param unknown_type $form_state
 * @param unknown_type $form
 */
function nodequeue_arrange_subqueue_form_add_validate($form, &$form_state) {
  $queue = nodequeue_load($form_state['values']['qid']);
  $subqueue = nodequeue_load($form_state['values']['sqid']);
  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $form_state['values']['add']);
  if (empty($nodes) || !is_array($nodes)) {
    form_error($form['add'], t('Invalid node'));
    return;
  }
  if (count($nodes) > 1) {
    form_error($form['add'], t('That matches too many nodes'));
    return;
  }
  $keys = array_keys($nodes);
  $nid = array_pop($keys);
  form_set_value($form['nid'], $nid, $form_state);
}

/**
 * Validate handler for nodequeue_arrange_subqueue_form for 'Save' button.
 *
 * @param unknown_type $form_id
 * @param unknown_type $form_state
 * @param unknown_type $form
 */
function nodequeue_arrange_subqueue_form_save_validate($form, &$form_state) {
  $nids = $form_state['values']['nids'];

  // We can't use array_merge because it'll reset our keys and we can't
  // use + because it will overwrite.
  if ($form_state['values']['added_nids']) {
    foreach (explode(',', $form_state['values']['added_nids']) as $nid) {
      if (empty($nids)) {
        $nids[1] = $nid;
      }
      else {
        $nids[max(array_keys($nids)) + 1] = $nid;
      }
    }
  }
  form_set_value($form['nids'], $nids, $form_state);
}

/**
 * Submit function for nodequeue_arrange_subqueue_form on 'Reverse' button.
 *
 * Yeah, this just calls the below function with a different parameter, but in D6 we're not supposed to use the $form['ops'].
 */
function nodequeue_arrange_subqueue_form_reverse_submit($form, &$form_state) {
  nodequeue_arrange_subqueue_form_submit($form, $form_state, TRUE, FALSE);
}

function nodequeue_arrange_subqueue_form_shuffle_submit($form, &$form_state) {
  nodequeue_arrange_subqueue_form_submit($form, $form_state, FALSE, TRUE);
}

/**
 * Submit function for nodequeue_arrange_subqueue_form
 */
//TODO: Form Submit - Revise for D6
function nodequeue_arrange_subqueue_form_submit($form, &$form_state, $reverse=FALSE, $shuffle=FALSE) {
  // Add a node to the queue if that's the intention.
  $queue = nodequeue_load($form_state['values']['qid']);
  $subqueue = nodequeue_load_subqueue($form_state['values']['sqid']);

  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $form_state['values']['sqid']);
  if ($form_state['values']['order']) {
    $now = time();
    $sql = '';
    $args = array();
    $nids = $form_state['values']['nids'];
    $subqueue->count = 0;
    $order = explode(',', $form_state['values']['order']);
    if ($queue->reverse xor $reverse) {
      $order = array_reverse($order);
    }

    foreach ($order as $new_pos => $old_pos) {
      if ($sql) {
        $sql .= ', ';
      }
      $sql .= ' (%d, %d, %d, %d, %d)';
      $args[] = $form_state['values']['sqid'];
      $args[] = $form_state['values']['qid'];
      $args[] = $nids[$old_pos];

      // $new_pos starts from 0 but we start from 1.
      $args[] = $new_pos + 1;
      $args[] = $now;
      $subqueue->count++;
    }
    $sql = "INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES $sql";
    db_query($sql, $args);
    if ($queue->size) {
        // 0 means infinity so never do this if false
        nodequeue_check_subqueue_size($queue, $subqueue);
    }
    if ($shuffle) { //$form_values['op'] == t('Shuffle')) {
      nodequeue_subqueue_shuffle($subqueue);
    }
  }
  drupal_set_message(t('The queue has been updated'));
}

function nodequeue_arrange_subqueue_form_clear_submit($form, &$form_state) {
  $form_state['redirect'] = 'admin/content/nodequeue/'. $form_state['values']['qid'] .'/clear/'. $form_state['values']['sqid'];
}

function nodequeue_arrange_subqueue_form_add_submit($form, &$form_state) {
  $queue = nodequeue_load($form_state['values']['qid']);
  $subqueue = nodequeue_load_subqueue($form_state['values']['sqid']);

  nodequeue_subqueue_add($queue, $subqueue, $form_state['values']['nid']);
}

/**
 * Page callback to move an item up in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_up($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_numeric($subqueue) || !nodequeue_check_token($pos)) {
    return drupal_goto();
  }
  $subqueue = nodequeue_load_subqueue($subqueue);
  // This function is safe if $pos is out of bounds.
  if (!$queue->reverse) {
    nodequeue_queue_up($subqueue, $pos);
  }
  else {
    nodequeue_queue_down($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item down in a queue. This will be used only if
 * javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_down($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_numeric($subqueue) || !nodequeue_check_token($pos)) {
    return drupal_goto();
  }
  $subqueue = nodequeue_load_subqueue($subqueue);
  // This function is safe if $pos is out of bounds.
  if ($queue->reverse) {
    nodequeue_queue_up($subqueue, $pos);
  }
  else {
    nodequeue_queue_down($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item to the front of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_front($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_numeric($subqueue) || !nodequeue_check_token($pos)) {
    return drupal_goto();
  }
  $subqueue = nodequeue_load_subqueue($subqueue);
  // This function is safe if $pos is out of bounds.
  if (!$queue->reverse) {
    nodequeue_queue_front($subqueue, $pos);
  }
  else {
    nodequeue_queue_back($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to move an item to the back of a queue. This will be used
 * only if javascript is disabled in the client, and is a fallback technique.
 */
function nodequeue_admin_back($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_numeric($subqueue) || !nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }
  $subqueue = nodequeue_load_subqueue($subqueue);
  // This function is safe if $pos is out of bounds.
  if ($queue->reverse) {
    nodequeue_queue_front($subqueue, $pos);
  }
  else {
    nodequeue_queue_back($subqueue, $pos);
  }

  drupal_goto();
}

/**
 * Page callback to remove an item from a queue. This will be used only
 * if javascript is disabled in the client, and is a fallback technique.
 * This differs from nodequeue_admin_remove_node in that it removes a
 * specific position, which is necessary in case a node is in a queue
 * multiple times.
 */
function nodequeue_admin_remove($queue, $subqueue, $pos) {
  if (!is_numeric($pos) || !is_numeric($subqueue) || !nodequeue_check_token($node->nid)) {
    return drupal_goto();
  }

  nodequeue_subqueue_remove($subqueue, $pos);

  drupal_goto();
}

/**
 * Confirm form to clear a queue.
 */
//TODO: Form - Revise for D6.
function nodequeue_clear_confirm(&$form_state, $queue, $subqueue) {
  if (!is_numeric($subqueue)) {
    return false;
  }
  drupal_set_title(t("Nodequeue '@title'", array('@title' => $queue->title)));
  $form['sqid'] = array('#type' => 'value', '#value' => $subqueue->sqid);
  $form['qid'] = array('#type' => 'value', '#value' => $queue->qid);
  return confirm_form($form,
    t('Clearing queue "%s" is irreversible. You sure?', array('%s' => nodequeue_title_substitute($queue->subqueue_title, $queue, $subqueue))),
    $_GET['destination'] ? $_GET['destination'] : "admin/content/nodequeue/$queue->qid/view/$subqueue->sqid",
    t('This action cannot be undone.'),
    t('Clear'), t('Cancel')
  );
}

/**
 * Submit function for nodequeue clear confirm
 */
//TODO: Form Submit - Revise for D6
function nodequeue_clear_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    nodequeue_queue_clear($form_state['values']['sqid']);
    $form_state['redirect'] = "admin/content/nodequeue/". $form_state['values']['qid'] ."/view/". $form_state['values']['sqid'];
  }
}

/**
 * Page callback for autocomplete.
 */
function nodequeue_autocomplete($sqid = NULL, $string = NULL) {
  $output = _nodequeue_autocomplete($sqid, $string);

  drupal_json(drupal_map_assoc($output));
  exit;
}

function _nodequeue_autocomplete($sqid, $string) {
  $output = array();

  if (!$sqid || !is_numeric($sqid) || !$string) {
    return $output;
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return $output;
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return $output;
  }

  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $string);
  return $nodes;
}

/**
 * Page callback to ajaxily add a node.
 */
function nodequeue_ajax_add() {
  $sqid = $_POST['sqid'];
  $position = $_POST['position'];
  $string = $_POST['add'];
  $output = _nodequeue_ajax_add($sqid, $position, $string);
  // let the world know this isn't normal output.
  drupal_json($output);
  exit;
}

function _nodequeue_ajax_add($sqid, $position, $string) {
  if (!$string) {
    return array('error' => t('Invalid input'));
  }

  if (!$sqid || !is_numeric($sqid)) {
    return array('error' => t('Invalid sqid'));
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return array('error' => t('Invalid sqid'));
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return array('error' => t('Invalid sqid'));
  }

  if (!nodequeue_api_subqueue_access($subqueue)) {
    return array('error' => t('Access denied'));
  }
 
  $nodes = nodequeue_api_autocomplete($queue, $subqueue, $string);
  if (empty($nodes) || !is_array($nodes)) {
    return array('error' => t('Invalid node'));
  }

  if (count($nodes) > 1) {
    return array('error' => t('That matches too many nodes'));
  }

  $keys = array_keys($nodes);
  $node = node_load(array_pop($keys));

  if (!node_access('view', $node)) {
    return array('error' => t('Invalid node'));
  }

  $node->position = $position;
  return array(
    'status' => 1,
    'extra' => $node->nid,
    'max' => $queue->size,
    'data' => nodequeue_arrange_subqueue_entry($queue, $subqueue, $node),
  );
}

// --------------------------------------------------------------------------
// Nodequeue manipulation API.

/**
 * @defgroup nodequeue_api
 * @{
 * Access to the internals of nodequeues are handled primarily through these
 * API functions. They allow easy loading of queues for manipulation.
 */

/**
 * The nodequeue queue class; the constructor makes it so we don't have to
 * always check to see if our variables are empty or not.
 */
class nodequeue_queue {
  var $title = '';
  var $size = 0;
  var $link = '';
  var $link_remove = '';
  var $roles = array();
  var $types = array();
  var $show_in_links = TRUE;
  var $show_in_tab = TRUE;
  var $show_in_ui = TRUE;
  var $reference = 0;
  var $i18n = 1;

  var $subqueue_title = '';
  var $reverse = FALSE;

  // runtime
  var $subqueues = array();
  var $subqueue = NULL;

  var $current = NULL;

  function nodequeue_queue($type) {
    $this->owner = $type;
  }
}

/**
 * Return TRUE If the specified account has access to manipulate this queue.
 */
function nodequeue_queue_access($queue, $subqueue = NULL, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  // Automatically true if all queues.
  if (user_access('manipulate all queues')) {
    return TRUE;
  }

  // Automatically false if they can't manipulate queues at all.
  if (!user_access('manipulate queues') || empty($queue->roles)) {
    return FALSE;
  }

  if (!nodequeue_api_queue_access($queue, $account)) {
    return FALSE;
  }

  if ($subqueue) {
    return nodequeue_api_subqueue_access($subqueue, $account);
  }

  $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);
  return (bool) array_intersect($roles, $queue->roles);
}

/**
 * Fetch a list of available queues for a given location. These queues
 * will be fully loaded and ready to go.
 */
function nodequeue_load_queues_by_type($type, $location = NULL, $account = NULL, $bypass_cache = FALSE) {
  $qids = nodequeue_get_qids($type, $account, $bypass_cache);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }
  return nodequeue_load_queues(array_keys($qids), $bypass_cache);
}

/**
 * Used by menu system to determine access to the node and the queue in question.
 *
 * No, this isn't some odd hook_access implementation.
 *
 * @param unknown_type $node
 * @param unknown_type $queue
 * @return unknown
 */
function nodequeue_node_and_queue_access($node, $queue, $subqueue = NULL) { 
  return nodequeue_node_access($node->type) && nodequeue_queue_access($queue, $subqueue);
}

function nodequeue_node_tab_access($node) {
  if (!user_access('manipulate queues')) { 
    //For performance reasons: If the user can't manipulate queues, there is no reason to run the rest of these queries.
    return FALSE;
  }
  $queues = nodequeue_load_queues_by_type($node->type, 'tab');
  $subqueues = nodequeue_get_subqueues_by_node($queues, $node);
  if (empty($subqueues)) {
    return FALSE;
  }
  foreach ($subqueues as $subqueue) {
    if (!nodequeue_api_subqueue_access($subqueue)) {
      unset($subqueues[$subqueue->sqid]);
    }
  }
  return (variable_get('nodequeue_use_tab', 1) && !empty($subqueues));
}
/**
 * Return TRUE if $user can queue(s) for this node.
 *
 * @param $type
 *   The node type.
 * @param $location
 *   Optional argument. May be one of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_node_access($type, $location = NULL, $account = NULL) {
  $qids = nodequeue_get_qids($type, $account);
  if ($location) {
    nodequeue_filter_qids($qids, $location);
  }

  return !empty($qids);
}

/**
 * Filter a list of qids returned by nodequeue_get_qids to a location.
 *
 * @param $qids
 *   An array of $qids from @see nodequeue_get_qids()
 * @param $location
 *   One of:
 *   - 'links': Only check for queues that have node links.
 *   - 'tab': Only check for queues that appear on the node tab.
 *   - 'ui': Only check for queues that appear in the UI.
 */
function nodequeue_filter_qids(&$qids, $location) {
  $var = "show_in_$location";
  foreach ($qids as $qid => $info) {
    if (empty($info->$var)) {
      unset($qids[$qid]);
    }
  }
}

/**
 * Get an array of qids applicable to this node type.
 *
 * @param $type
 *   The node type.
 * @param $account
 *   The account to test against. Defaults to the currently logged in user.
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *   => true/false, 'show_in_links' => true/false }
 * 
 * @param $bypass_cache
 *  Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_get_qids($type, $account = NULL, $bypass_cache = FALSE) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }

  static $cache = array();
  if ($bypass_cache || !isset($cache[$type])) {
    $roles_join = $roles_where = '';
    $roles = array();

    // superuser always has access.
    if (!user_access('manipulate all queues', $account)) {
      $roles_join = "INNER JOIN {nodequeue_roles} nr ON nr.qid = nq.qid ";
      $roles = array_keys((array) $account->roles) + array(DRUPAL_AUTHENTICATED_RID);

      $roles_where .= "AND nr.rid IN (". db_placeholders($roles, 'int') .")";
    }

    $sql = 'SELECT nq.qid, nq.show_in_tab, nq.show_in_links, nq.show_in_ui, nq.i18n '.
      'FROM {nodequeue_queue} nq '.
      'INNER JOIN {nodequeue_types} nt ON nt.qid = nq.qid '. $roles_join .
      "WHERE nt.type = '%s' ". $roles_where;
    $result = db_query($sql, array_merge(array($type), $roles));

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid;
    }
    $cache[$type] = $qids;
  }
  return $cache[$type];
}

/**
 * Get an array all qids using the pager query. This administrative list
 * does no permission checking, so should only be available to users who
 * have passed the 'administer queues' check.
 *
 * @param $page_size
 *   The page size to use. If 0 will be all queues.
 * @param $pager_element
 *   In the rare event this should use another pager element, set this..
 *
 * @return $qids
 *   An array in the format: @code { array($qid => array('qid' => $qid, 'show_in_tab' '
 *    => true/false, 'show_in_links' => true/false }
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_get_all_qids($page_size = 25, $pager_element = 0, $bypass_cache = FALSE) {
  static $cache = NULL;
  if ($bypass_cache || !isset($cache)) {
    $sql = 'SELECT nq.qid '.
           'FROM {nodequeue_queue} nq '.
           'WHERE nq.show_in_ui = 1 ';
    $count_sql = 'SELECT COUNT(q.qid) FROM {nodequeue_queue} q WHERE q.show_in_ui = 1 ';
    if ($page_size) {
      $result = pager_query($sql, $page_size, $pager_element, $count_sql);
    }
    else {
      $result = db_query($sql, $count_sql);
    }

    $qids = array();
    while ($qid = db_fetch_object($result)) {
      $qids[$qid->qid] = $qid->qid;
    }
    $cache = $qids;
  }
  return $cache;
}

/**
 * Load an array of $qids.
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $qids
 *   An array of queue IDs to load.
 * 
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_queues($qids = array(), $bypass_cache = FALSE) {
  static $cache = array();
  $to_load = $queues = array();

  foreach ($qids as $qid) {
    if ($bypass_cache || !isset($cache[$qid])) {
      $to_load[] = $qid;
    }
  }

  if (!empty($to_load)) {
    $placeholders = db_placeholders($to_load, 'int');
    $result = db_query("SELECT q.*, COUNT(s.sqid) AS subqueues FROM {nodequeue_queue} q LEFT JOIN {nodequeue_subqueue} s ON q.qid = s.qid WHERE q.qid IN ($placeholders) GROUP BY q.qid", $to_load);
    while ($queue = db_fetch_object($result)) {
      $cache[$queue->qid] = $queue;
      // ensure valid defaults:
      $cache[$queue->qid]->types = array();
      $cache[$queue->qid]->roles = array();
      $cache[$queue->qid]->count = 0;
    }

    $result = db_query("SELECT qid, rid FROM {nodequeue_roles} WHERE qid IN ($placeholders)", $to_load);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->roles[] = $obj->rid;
    }

    $result = db_query("SELECT qid, type FROM {nodequeue_types} WHERE qid IN ($placeholders)", $to_load);
    while ($obj = db_fetch_object($result)) {
      $cache[$obj->qid]->types[] = $obj->type;
    }
  }

  foreach ($qids as $qid) {
    if (isset($cache[$qid])) {
      $queues[$qid] = $cache[$qid];
    }
  }
  return $queues;
}

/**
 * Load a nodequeue.
 *
 * @param $qid
 *   The qid of the queue to load.
 */
function nodequeue_load($qid) {
  $queues = nodequeue_load_queues(array($qid));
  return array_shift($queues);
}

/**
 * This function exists so that %subqueue will work in hook_menu.
 */
function subqueue_load($sqid) {
  if (!$sqid) {
    return NULL;
  }
  return array_shift(nodequeue_load_subqueues(array($sqid)));
}

/**
 * Load a list of subqueues
 *
 * This exists to provide a way of loading a bunch of queues with
 * the fewest queries. Loading 5 queues results in only 4 queries,
 * not 20. This also caches queues so that they don't get loaded
 * repeatedly.
 *
 * @param $sqids
 *   An array of subqueue IDs to load.
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_subqueues($sqids, $bypass_cache = FALSE) {
  static $cache = array();
  $to_load = array();

  foreach ($sqids as $sqid) {
    if ($bypass_cache || !isset($cache[$sqid])) {
      $to_load[] = $sqid;
    }
  }

  if (!empty($to_load)) {
    $placeholders = db_placeholders($to_load, 'int');

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.sqid IN ($placeholders) GROUP BY s.sqid", $to_load);
    while ($obj = db_fetch_object($result)) {
      // Sometimes we want to get to subqueues by reference, sometimes by sqid.
      // sqid is always unique, but reference is sometimes more readily available.
      $cache[$obj->sqid] = $obj;
    }
  }

  foreach ($sqids as $sqid) {
    if (isset($cache[$sqid])) {
      $subqueues[$sqid] = $cache[$sqid];
    }
  }
  return $subqueues;
}

/**
 * Load a single subqueue.
 *
 * @param $sqid
 *   The subqueue ID to load.
 * @param $bypass_cache
 *   Boolean value indicating whether to bypass the cache or not.
 */
function nodequeue_load_subqueue($sqid, $bypass_cache = FALSE) {
  $subqueues = nodequeue_load_subqueues(array($sqid), $bypass_cache);
  if ($subqueues) {
    return array_shift($subqueues);
  }

}

/**
 * Load the entire set of subqueues for a queue.
 *
 * This will load the entire set of subqueues for a given queue (and can
 * respect the pager, if desired). It does NOT cache the subqueues like
 * nodequeue_load_subqueues does, so beware of this mixed caching.
 *
 * @param $qids
 *   A $qid or array of $qids
 * @param $page_size
 *   If non-zero, use the pager_query and limit the page-size to the parameter.
 */
function nodequeue_load_subqueues_by_queue($qids, $page_size = 0) {
  if (is_numeric($qids)) {
    $qids = array($qids);
  }

  if (empty($qids)) {
    return array();
  }

  $query = "SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE s.qid IN (". db_placeholders($qids, 'int') .") GROUP BY s.sqid";
  if ($page_size) {
    $result = pager_query($query, $page_size, 0, $qids);
  }
  else {
    $result = db_query($query, $qids);
  }

  $subqueues = array();

  while ($subqueue = db_fetch_object($result)) {
    $subqueues[$subqueue->sqid] = $subqueue;
  }

  return $subqueues;
}

/**
 * Load a set of subqueues by reference.
 *
 * This can be used to load a set of subqueues by reference; it will primarily
 * be used by plugins that are managing subqueues.
 *
 * @param $references
 *   A keyed array of references to load. The key is the $qid and each value
 *   is another array of references.
 */
function nodequeue_load_subqueues_by_reference($references) {
  static $cache = array();
  $subqueues = array();

  // build strings for the query based upon the qids and references.
  $keys = $values = array();
  foreach ($references as $qid => $qid_references) {
    $keys[$qid] = array();
    $qid_values = array();
    foreach ($qid_references as $reference) {
      // If we already have this qid/reference combo cached, don't add it to
      // our little list.
      if (isset($cache[$qid][$reference])) {
        $subqueues[$cache[$qid][$reference]->sqid] = $cache[$qid][$reference];
      }
      else {
        $keys[$qid][] = "'%s'"; // Substitution strings
        $qid_values[] = $reference; // Values to substitute
      }
    }
    if (!empty($keys[$qid])) {
      $values = array_merge($values, array($qid), $qid_values);
    }
    else {
      unset($keys[$qid]);
    }
  }

  if (!empty($keys)) {
    $where = '';
    foreach ($keys as $key_list) {
      if ($where) {
        $where .= ' OR ';
      }
      $where .= 's.qid = %d AND s.reference IN ('. implode(', ', $key_list) .')';
    }

    $result = db_query("SELECT s.*, COUNT(n.position) AS count FROM {nodequeue_subqueue} s LEFT JOIN {nodequeue_nodes} n ON n.sqid = s.sqid WHERE $where GROUP BY s.sqid", $values);

    while ($subqueue = db_fetch_object($result)) {
      $cache[$subqueue->qid][$subqueue->reference] = $subqueues[$subqueue->sqid] = $subqueue;
    }
  }

  return $subqueues;
}

/**
 * Save a nodequeue. This does not save subqueues; those must be added separately.
 */
function nodequeue_save(&$queue) {
  if (!isset($queue->qid)) {
    db_query("INSERT INTO {nodequeue_queue} (title, subqueue_title, size, link, link_remove, owner, show_in_links, show_in_tab, show_in_ui, i18n, reverse, reference) VALUES ('%s', '%s', %d, '%s', '%s', '%s', %d, %d, %d, %d, %d, '%s')", $queue->title, $queue->subqueue_title, $queue->size, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->i18n, $queue->reverse, $queue->reference);
    $queue->qid = db_last_insert_id('nodequeue_queue', 'qid');
    if (function_exists('views_invalidate_cache')) {
      views_invalidate_cache();
    }
  }
  else {
    db_query("UPDATE {nodequeue_queue} set size = %d, title = '%s', subqueue_title = '%s', link = '%s', link_remove = '%s', owner = '%s', show_in_links = %d, show_in_tab = %d, show_in_ui = %d, i18n = %d, reverse = %d, reference = '%s' WHERE qid = %d", $queue->size, $queue->title, $queue->subqueue_title, $queue->link, $queue->link_remove, $queue->owner, $queue->show_in_links, $queue->show_in_tab, $queue->show_in_ui, $queue->i18n, $queue->reverse, $queue->reference, $queue->qid);
    db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $queue->qid);
    db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $queue->qid);
  }

  if (is_array($queue->roles)) {
    foreach ($queue->roles as $rid)
      db_query("INSERT INTO {nodequeue_roles} (qid, rid) VALUES (%d, %d)", $queue->qid, $rid);
  }

  if (is_array($queue->types)) {
    foreach ($queue->types as $type)
      db_query("INSERT INTO {nodequeue_types} (qid, type) VALUES (%d, '%s')", $queue->qid, $type);
  }

  // set our global that tells us whether or not we need to activate hook_link
  if (db_result(db_query("SELECT COUNT(*) FROM {nodequeue_queue} WHERE link <> ''"))) {
    variable_set('nodequeue_links', TRUE);
  }
  else {
    variable_set('nodequeue_links', FALSE);
  }

  if (isset($queue->add_subqueue) && is_array($queue->add_subqueue)) {
    foreach ($queue->add_subqueue as $reference => $title) {
      // If reference is unset it should be set to the qid; this is generally
      // used for a single subqueue; setting the reference to the qid makes
      // it easy to find that one subqueue.
      if ($reference == 0) {
        $reference = $queue->qid;
      }
      nodequeue_add_subqueue($queue, $title, $reference);
    }
  }
  return $queue->qid;
}

/**
 * Delete a nodequeue.
 */
function nodequeue_delete($qid) {
  db_query("DELETE FROM {nodequeue_queue} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_roles} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_types} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_nodes} WHERE qid = %d", $qid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE qid = %d", $qid);
}

/**
 * Add a new subqueue to a queue.
 *
 * @param $qid
 *   The queue id. This should not be the full queue object.
 * @param $reference
 *   A reference that uniquely identifies this subqueue. If NULL it will
 *   be assigned to the sqid.
 */
function nodequeue_add_subqueue(&$queue, $title, $reference = NULL) {
  if (empty($reference)) {
    $insert_reference = "";
  }
  else {
    $insert_reference = $reference;
  }

  $subqueue = new stdClass();;
  $subqueue->reference = $reference;
  $subqueue->qid = $queue->qid;
  $subqueue->title = $title;

  db_query("INSERT INTO {nodequeue_subqueue} (qid, reference, title) VALUES (%d, '%s', '%s')", $queue->qid, $insert_reference, $title);

  $subqueue->sqid = db_last_insert_id('nodequeue_subqueue', 'sqid');

  // If somehow the $reference is null, here we set it to the sqid.
  // We have to do it here, because before the insert we don't know what the sqid will be.
  if (empty($reference)) {
    db_query("UPDATE {nodequeue_subqueue} SET reference = '%s' WHERE sqid = %d", $subqueue->sqid, $subqueue->sqid);
  }

  return $subqueue;
}

/**
 * Change the title of a subqueue.
 *
 * Note that only the title of a subqueue is changeable; it can change to
 * reflect updates in taxonomy term names, for example.
 */
function nodequeue_subqueue_update_title($sqid, $title) {
  db_query("UPDATE {nodequeue_subqueue} SET title = '%s' WHERE sqid = %d", $title, $sqid);
}

/**
 * Remove a subqueue.
 */
function nodequeue_remove_subqueue($sqid) {
  nodequeue_queue_clear($sqid);
  db_query("DELETE FROM {nodequeue_subqueue} WHERE sqid = %d", $sqid);
}

// --------------------------------------------------------------------------
// Queue position control

/**
 * Add a node to a queue.
 *
 * @param $queue
 *   The parent queue of the subqueue. This is required so that we can
 *   pop nodes out if the queue breaks size limits.
 * @param $sqid
 *   The subqueue ID to add the node to.
 * @param $nid
 *   The node ID
 */
function nodequeue_subqueue_add($queue, $subqueue, $nid) {
  // If adding this would make the queue too big, pop the front node
  // (or nodes) out.

  if ($queue->size) {
    // 0 means infinity so never do this if false
    nodequeue_check_subqueue_size($queue, $subqueue, $queue->size - 1);
  }

  db_query("INSERT INTO {nodequeue_nodes} (sqid, qid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $subqueue->sqid, $queue->qid, $nid, $subqueue->count + 1, time());
}

/**
 * Remove a node from the queue. If a node is in the queue more than once,
 * only the first (closest to 0 position, or the front of the queue) will
 * be removed.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $nid
 *   The node to remove.
 */
function nodequeue_subqueue_remove_node($sqid, $nid) {
  if ($pos = nodequeue_get_subqueue_position($sqid, $nid)) {
    nodequeue_subqueue_remove($sqid, $pos);
  }
}
/**
 * Remove a node or node(s) from a nodequeue by position.
 *
 * If you know the nid but but not the position, use
 * @see nodequeue_subqueue_remove_node() instead.
 *
 * @param $sqid
 *   The subqueue to remove nodes from.
 * @param $start
 *   The first position (starting from 1) to remove.
 * @param $end
 *   The last position to remove. If NULL or equal to $start,
 *   only one node will be removed. Thus if $start is 1 and $end is 2,
 *   the first and second items will be removed from the queue.
 *
 */
function nodequeue_subqueue_remove($sqid, $start, $end = NULL) {
  if (!isset($end)) {
    $end = $start;
  }

  $diff = $end - $start + 1;
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position >= %d AND position <= %d", $sqid, $start, $end);
  db_query("UPDATE {nodequeue_nodes} SET position = position - %d WHERE sqid = %d AND position > %d",  $diff, $sqid, $end);
}

/**
 * Empty a subqueue.
 *
 * @param $sqid
 *   The sqid to empty.
 */
function nodequeue_queue_clear($sqid) {
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d", $sqid);
}

/**
 * Guarantee that a subqueue has not gotten too big. It's important to call
 * this after an operation that might have reduced a queue's maximum size.
 * It stores the count to save a query if this is to be followed by an add
 * operation.
 *
 * @param $queue
 *   The queue object.
 * @param $reference
 *   The subqueue to check.
 *
 */
function nodequeue_check_subqueue_size($queue, &$subqueue, $size = NULL) {
  if (!isset($size)) {
    $size = $queue->size;
  }

  if ($queue->size && $subqueue->count > $size) {
    nodequeue_subqueue_remove($subqueue->sqid, 1, $subqueue->count - $size);
    $subqueue->count = $size;
  }
}

/**
 * Guarantee that all subqueues are within the size constraints set
 * by $queue->size.
 */
function nodequeue_check_subqueue_sizes($queue) {
  // Don't check if size is 0, as that means infinite size.
  if (!$queue->size) {
    return;
  }

  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
  foreach ($subqueues as $subqueue) {
    nodequeue_check_subqueue_size($queue, $subqueue);
  }
}

/**
 * Swap two positions within a subqueue.
 */
function nodequeue_queue_swap($subqueue, $pos1, $pos2) {
  // Grab the nid off one of the positions so we can more easily swap.
  $nid = db_result(db_query("SELECT nid FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $pos1));
  if (!$nid) {
    return;
  }

  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE position = %d AND sqid = %d", $pos1, $pos2,  $subqueue->sqid);
  db_query("UPDATE {nodequeue_nodes} SET position = %d WHERE nid = %d AND sqid = %d", $pos2, $nid, $subqueue->sqid);
}

/**
 * Move a position within a subqueue up by one.
 */
function nodequeue_queue_up($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position - 1, $position);
}

/**
 * Move a position within a subqueue down by one.
 */
function nodequeue_queue_down($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  nodequeue_queue_swap($subqueue, $position + 1, $position);
}

/**
 * Move an item to the front of the queue.
 */
function nodequeue_queue_front($subqueue, $position) {
  if ($position < 2 || $position > $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid= %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position + 1 WHERE sqid= %d AND position < %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, 1, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $entry->timestamp);
}

/**
 * Move an item to the back of the queue.
 */
function nodequeue_queue_back($subqueue, $position) {
  if ($position < 1 || $position >= $subqueue->count)
    return;
  $entry = db_fetch_object(db_query("SELECT * FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position));
  db_query("DELETE FROM {nodequeue_nodes} WHERE sqid = %d AND position = %d", $subqueue->sqid, $position);
  db_query("UPDATE {nodequeue_nodes} SET position = position - 1 WHERE sqid = %d AND position > %d", $subqueue->sqid, $position);
  db_query("INSERT INTO {nodequeue_nodes} (qid, sqid, nid, position, timestamp) VALUES (%d, %d, %d, %d, %d)", $entry->qid, $subqueue->sqid, $entry->nid, $subqueue->count, $entry->timestamp);
}

/**
 * Get the position of a node in a subqueue, or 0 if not found.
 */
function nodequeue_get_subqueue_position($sqid, $nid) {
  // We use MIN to make sure we always get the closes to the front of the
  // queue in case the queue has nodes in it multiple times.
  $pos = db_result(db_query("SELECT MIN(position) FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
  return $pos;
}

/**
 * Get the position of a node in several subqueues.
 */
function nodequeue_set_subqueue_positions(&$subqueues, $nid) {
  $placeholders = db_placeholders($subqueues, 'int');
  $args = array_keys($subqueues);
  $args[] = $nid;
  $result = db_query("SELECT sqid, MIN(position) AS position FROM {nodequeue_nodes} WHERE sqid IN ($placeholders) AND nid = %d GROUP BY sqid", $args);
  while ($obj = db_fetch_object($result)) {
    $subqueues[$obj->sqid]->position = $obj->position;
  }
}

/**
 * Get a list of valid subqueues for a node, along with the position of the node.
 *
 * @param $queues
 *   An array of fully loaded queue objects.
 * @param $node
 *   A fully loaded node object.
 *
 */
function nodequeue_get_subqueues_by_node($queues, $node) {
  // Determine which subqueues are valid for each queue.
  $references= array();
  foreach ($queues as $queue) {
    if ($result = nodequeue_api_subqueues($queue, $node)) {
      $references[$queue->qid] = is_array($result) ? $result : array($result);
    }
  }

  if (empty($references)) {
    return;
  }

  return nodequeue_load_subqueues_by_reference($references);
}

/**
 * Get a textual representation of a nodequeue's queue size.
 */
function nodequeue_subqueue_size_text($max, $count, $long = TRUE) {
  if (empty($count)) {
    $message = theme('nodequeue_subqueue_empty_text');
  }
  else if ($count == $max) {
    $message = theme('nodequeue_subqueue_full_text');
  }
  else {
    if ($long) {
      $message = theme('nodequeue_subqueue_count_text', $count);
    }
    else {
      $message = $count;
    }
  }
  return $message;
}

function theme_nodequeue_subqueue_empty_text() {
  return t('Queue empty');
}

function theme_nodequeue_subqueue_full_text() {
  return t('Queue full');
}

function theme_nodequeue_subqueue_count_text($count) {
  return t('@count in queue', array('@count' => $count));
}

/**
 * Substitute the subqueue title into some other string.
 *
 * This function does NOT check_plain the title! The output MUST be checked
 * after this is complete.
 */
function nodequeue_title_substitute($text, $queue, $subqueue) {
  if (empty($text)) {
    return $subqueue->title;
  }
  $text = str_replace('%subqueue', $subqueue->title, $text);
  return $text;
}

/**
 * Shuffle a queue.
 *
 * @param $subqueue
 *   The subqueue to shuffle. May be a sqid or the loaded object.
 */
function nodequeue_subqueue_shuffle($subqueue) {
  // Load the queue
  if (!is_object($subqueue)) {
    $subqueue = nodequeue_load_subqueue($subqueue);
  }

  if (empty($subqueue)) {
    return;
  }

  $count = $subqueue->count;
  // Swap each item with another randomly picked one.
  foreach (range(1, $count) as $i) {
    nodequeue_queue_swap($subqueue, $i, rand(1, $count));
  }
}

/**
 * @} End of defgroup "nodequeue_api"
 */

// --------------------------------------------------------------------------
// Hooks to implement the default nodequeue type.

/**
 * Implementation of hook_nodequeue_info()
 */
function nodequeue_nodequeue_info() {
  return array('nodequeue' => array(
    'title' => t('Nodequeue'),
    'description' => t('Standard nodequeues have just one subqueue. Nodes put into a queue are added to the back of the queue; when a node is added to a full queue, the node in the front of the queue will be popped out to make room.'),
    ));
}

/**
 * Implementation of hook_nodequeue_form_submit()
 */
function nodequeue_nodequeue_form_submit(&$queue, $form_state) {
  // This will add a single subqueue to our new queue.
  if (!isset($queue->qid) && !isset($queue->add_subqueue)) {
    // A 0 will set the reference to the sqid of the queue.
    $queue->add_subqueue = array(0 => $queue->title);
  }
}

// --------------------------------------------------------------------------
// External queue fetching

/**
 * in general it's preferable to use Views for this functionality.
 */
function nodequeue_node_titles($sqid, $title = '', $backward = true, $from = 0, $count = 0) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid, n.title FROM {node} n LEFT JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }
  return node_title_list($result, $title);
}

/**
 * Get node_view output from a nodequeue
 */
function nodequeue_view_nodes($sqid, $backward = TRUE, $teaser = TRUE, $links = TRUE, $from = 0, $count = 0) {
  $nodes = nodequeue_load_nodes($sqid, $backward, $from, $count);
  foreach ($nodes as $node) {
    $output .= node_view($node, $teaser, FALSE, $links);
  }
  return $output;
}

/**
 * Load an array of node objects belonging to a particular nodequeue.
 */
function nodequeue_load_nodes($sqid, $backward = FALSE, $from = 0, $count = 5) {
  $orderby = ($backward ? "DESC" : "ASC");
  $sql = db_rewrite_sql("SELECT n.nid FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1 ORDER BY nn.position $orderby");
  if ($count) {
    $result = db_query_range($sql, $sqid, $from, $count);
  }
  else {
    $result = db_query($sql, $sqid);
  }

  while ($nid = db_fetch_object($result)) {
    $nodes[] = node_load($nid->nid);
  }

  return $nodes;
}

/**
 * Load the first node of a queue
 */
function nodequeue_load_front($sqid) {
  $nodes = nodequeue_load_nodes($sqid, FALSE, 0, 1);
  return $nodes;
}

/**
 * Load the last node of a queue
 */
function nodequeue_load_back($sqid, $teaser = TRUE, $links = TRUE) {
  return nodequeue_load_nodes($sqid, TRUE, 0, 1);
}

/**
 * View a random node from a queue
 */
function nodequeue_view_random_node($sqid, $teaser = TRUE, $links = TRUE) {
  $count = db_result(db_query(db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1"), $sqid));
  return nodequeue_view_nodes($sqid, FALSE, $teaser, $links, rand(0, $count - 1), 1);
}

/**
 * Load a random node object from a queue
 */
function nodequeue_load_random_node($sqid) {
  $count = db_result(db_query(db_rewrite_sql("SELECT COUNT(n.nid) FROM {node} n INNER JOIN {nodequeue_nodes} nn ON n.nid = nn.nid WHERE nn.sqid = %d AND n.status = 1"), $sqid));
  return array_shift(nodequeue_load_nodes($sqid, TRUE, rand(0, $count - 1), 1));
}

/**
* Get the position of a node in a subqueue, or FALSE if not found.
*/
function nodequeue_subqueue_position($sqid, $nid) {
  return db_result(db_query("SELECT position FROM {nodequeue_nodes} WHERE sqid = %d AND nid = %d", $sqid, $nid));
}

/**
 * Get the position of a node in a queue; this queue MUST have only one
 * subqueue or the results of this function will be unpredictable.
 */
function nodequeue_queue_position($qid, $nid) {
  $sqid = db_result(db_query_range("SELECT sqid FROM {nodequeue_subqueue} WHERE qid = %d", $qid, 0, 1));
  return nodequeue_subqueue_position($sqid, $nid);
}

// --------------------------------------------------------------------------
// API for modules implementing subqueues.

/**
 * Send the nodequeue edit form to the owning module for modification.
 *
 * @param $queue
 *   The queue being edited.
 * @param &$form
 *   The form. This may be modified.
 */
//TODO: Form modifying code - Modify for D6?
function nodequeue_api_queue_form($queue, &$form) {
  $function = $queue->owner ."_nodequeue_form";
  if (function_exists($function)) {
    $function($queue, $form);
  }
}

/**
 * Validate the nodequeue edit form.
 *
 * @param $queue
 *   The queue being edited.
 * @param $form_state
 *   The form values that were submitted.
 * @param &$form
 *   The actual form object. This may be modified.
 */
function nodequeue_api_queue_form_validate($queue, &$form_state, &$form) {
  $function = $queue->owner ."_nodequeue_form_validate";
  if (function_exists($function)) {
    $function($queue, $form_state, $form);
  }
}

/**
 * Send the nodequeue edit form to the owning module upon submit.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_state
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit(&$queue, &$form_state) {
  $function = $queue->owner ."_nodequeue_form_submit";
  if (function_exists($function)) {
    $function($queue, $form_state);
  }
}

/**
 * Send the nodequeue edit form to the owning module after the queue
 * has been saved.
 *
 * @param &$queue
 *   The queue being edited. This may be modified prior to being
 *   saved.
 * @param $form_state
 *   The form values that were submitted.
 */
function nodequeue_api_queue_form_submit_finish($queue, &$form_state) {
  $function = $queue->owner ."_nodequeue_form_submit_finish";
  if (function_exists($function)) {
    $function($queue, $form_state);
  }
}

/**
 * Fetch a list of subqueues that are valid for this node from
 * the owning module.
 *
 * @param $queue
 *   The queue being edited.
 * @param $node
 *   The loaded node object being checked.
 *
 * @return
 *   An array of subqueues. This will be keyed by $sqid.
 */
function nodequeue_api_subqueues(&$queue, $node) {
  $function = $queue->owner ."_nodequeue_subqueues";
  // This will return an array of references.
  if (function_exists($function)) {
    return $function($queue, $node);
  }
  else {
    return $queue->qid;
  }
}

/**
 * Fetch a list of nodes available to a given subqueue
 * for autocomplete.
 *
 * @param $queue
 *   The queue that owns the subqueue
 * @param $subqueue
 *   The subqueue
 * @param $string
 *   The string being matched.
 *
 * @return
 *   An keyed array $nid => $title
 */
function nodequeue_api_autocomplete($queue, $subqueue, $string) {
  $matches = array();
  if (empty($string)) {
    return $matches;
  }


  $where = "n.type IN (". db_placeholders($queue->types, 'varchar') .')';
  $where_args = $queue->types;

  // Run a match to see if they're specifying by nid.
  $preg_matches = array();
  $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
  if (!$match) {
    $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
  }

  if ($match) {
    // If it found a nid via specification, reduce our resultset to just that nid.
    $where .= " AND n.nid = %d";
    array_push($where_args, $preg_matches[1]);
  }
  else {
    // Build the constant parts of the query.
    $where .= " AND LOWER(n.title) LIKE LOWER('%s%%')";
    array_push($where_args, $string);
  }

  // Call to the API.
  $function = $queue->owner ."_nodequeue_autocomplete";
  if (function_exists($function)) {
    return $function($queue, $subqueue, $string, $where, $where_args);
  }
  else {
    $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title FROM {node} n WHERE $where"), $where_args, 0, 10);
    while ($node = db_fetch_object($result)) {
      $matches[$node->nid] = check_plain($node->title) ." [nid: $node->nid]";
    }
  }

  return $matches;
}

/**
 * Collect info about all of the possible nodequeue types from owning
 * modules.
 */
function nodequeue_api_info() {
  return module_invoke_all('nodequeue_info');
}

function nodequeue_api_queue_access($queue, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if ($queue->owner != 'nodequeue') { // Avoids an infinite loop.
    $function = $queue->owner . '_queue_access';
    if (function_exists($function)) {
      $access = $function($queue, $account);
    }
  }

  if (!isset($access)) {
    $access = TRUE;
  }
  return $access;
}

/**
 * Allows the owning module of a subqueue to restrict access to viewing and
 * manipulating the queue.
 */
function nodequeue_api_subqueue_access($subqueue, $account = NULL, $queue = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }
  
  if (!$queue) {
    $queue = nodequeue_load($subqueue->qid);
  }

  $function = $queue->owner . '_subqueue_access';
  if (function_exists($function)) {
    $access = $function($subqueue, $account, $queue);
  }

  if (!isset($access)) {
    $access = TRUE;
  }

  return $access;
}
/**
 * Form builder for the nodequeue settings tab.
 */
function nodequeue_admin_settings() {
  $form = array();
  $form['nodequeue_use_tab'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create a menu tab for each node that could belong to any queues'),
    '#default_value' => variable_get('nodequeue_use_tab', 1),
  );
  $form['nodequeue_tab_display_max'] = array(
    '#type' => 'checkbox',
    '#title' => t('Include a column on the nodequeue tab for the maximum number of nodes in each queue'),
    '#default_value' => variable_get('nodequeue_tab_display_max', 1),
  );
  $form['nodequeue_tab_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Nodequeue tab label'),
    '#default_value' => variable_get('nodequeue_tab_name', t('Nodequeue')),
    '#description' => t('If nodes will have a menu tab for manipulating related nodequeues, what should that tab be called?'),
  );
  return system_settings_form($form);
}

/**
 * Generate a query string to use on nodequeue's private links.
 *
 * @param $seed
 *   The seed to use when generating a token. If NULL no token will
 *   be generated.
 * @param $destination
 *   The destination to use. If FALSE one won't be used; if TRUE
 *   one will be generated from drupal_get_destination().
 * @param $query
 *   An array of additional items to add to the query.
 *
 * @return
 *   The query string suitable for use in the l() function.
 */
function nodequeue_get_query_string($seed, $destination = FALSE, $query = array()) {
  if ($dest = drupal_get_destination()) {
    $query[] = $dest;
  }

  if (isset($seed)) {
    $query[] = nodequeue_get_token($seed);
  }

  return implode('&', $query);
}

/**
 * Get a private token used to protect nodequeue's links from spoofing.
 */
function nodequeue_get_token($nid) {
  return 'token='. drupal_get_token($nid);
}

/**
 * Check to see if the token generated from seed matches.
 */
function nodequeue_check_token($seed) {
  return drupal_get_token($seed) == $_GET['token'];
}
